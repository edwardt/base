/**
 * @file epl_scan.l
 * @brief Flex specification for EPL parser (use flex 2.5.35 or later)
 *
 * @author cjeong
 */

/*
 * -*- definitions -*-
 */
%{
#include <cstdlib>
#include <cerrno>
#include <climits>
#include <string>
#include <stdlib.h>
#include "mv/epl/epl_parser_driver.h" /* ParserDriver */
#include "epl_parse.hpp"              /* generated by bison */

typedef mv::epl::yy::Parser::token token;

/* Workaround for incompatibility in flex (2.5.31 through 2.5.33). */
#undef yywrap
#define yywrap() 1

/* By default, yylex returns int, we use token_type. Unfortunately,
   yyterminate by default returns 0, which is not of token_type. */
#define yyterminate() return token::EPL_TOK_END
%}

/* options: reentrant option is not usable as long as yyin needs to set 
   in epl_driver */
%option yylineno
%option full
%option noyywrap 
%option nounput 
%option batch 
%option debug 

/* definitions */
alpha   [A-Za-z]
alnum   [A-Za-z0-9]
digit   [0-9]
quote   [\"]
id      {alpha}{alnum}*
number  {digit}*("."{digit}*)?
strchar [^\"\n\\]
escape  "\\."
/*string  {quote}({strchar}|{escape})*{quote} */
string  {quote}({alpha})*{quote}
blank   [ \t]
newline [\n]

%x COMMENT
%{
#define YY_USER_ACTION yylloc->columns(yyleng);
%}

/* 
 * -*- rules -*- 
 */
%%
%{
  yylloc->step();
%}

"#"                       { BEGIN(COMMENT); }

"select"                  { return token::EPL_TOK_SELECT; }
"from"                    { return token::EPL_TOK_FROM; }
"where"                   { return token::EPL_TOK_WHERE; }
"as"                      { return token::EPL_TOK_AS; }
"retain"                  { return token::EPL_TOK_RETAIN; }
"events"                  { return token::EPL_TOK_EVENTS; }
"time"                    { return token::EPL_TOK_TIME; }
"milliseconds"            { return token::EPL_TOK_MILLISECONDS; }
"seconds"                 { return token::EPL_TOK_SECONDS; }
"minutes"                 { return token::EPL_TOK_MINUTES; }
"hours"                   { return token::EPL_TOK_HOURS; }
"days"                    { return token::EPL_TOK_DAYS; }
"create"                  { return token::EPL_TOK_CREATE; }
"schema"                  { return token::EPL_TOK_SCHEMA; }
"window"                  { return token::EPL_TOK_WINDOW; }

"module"                  { return token::EPL_TOK_MODULE; }
"process"                 { return token::EPL_TOK_PROCESS; }
"function"                { return token::EPL_TOK_FUNCTION; }
"event"                   { return token::EPL_TOK_EVENT; }
"type"                    { return token::EPL_TOK_TYPE; }
"var"                     { return token::EPL_TOK_VAR; }
"struct"                  { return token::EPL_TOK_STRUCT; }
"array"                   { return token::EPL_TOK_ARRAY; }
"of"                      { return token::EPL_TOK_OF; }
"void"                    { return token::EPL_TOK_VOID; }
"bool"                    { return token::EPL_TOK_BOOL; }
"char"                    { return token::EPL_TOK_CHAR; }
"short"                   { return token::EPL_TOK_SHORT; }
"integer"                 { return token::EPL_TOK_INT; }
"long"                    { return token::EPL_TOK_LONG; }
"float"                   { return token::EPL_TOK_FLOAT; }
"double"                  { return token::EPL_TOK_DOUBLE; }
"string"                  { return token::EPL_TOK_STRINGT; }
"if"                      { return token::EPL_TOK_IF; }
"else"                    { return token::EPL_TOK_ELSE; }
"while"                   { return token::EPL_TOK_WHILE; }
"for"                     { return token::EPL_TOK_FOR; }
"->"                      { return token::EPL_TOK_TRIGGER; }
"return"                  { return token::EPL_TOK_RETURN; }
"continue"                { return token::EPL_TOK_CONTINUE; }
"break"                   { return token::EPL_TOK_BREAK; }

"{"                       { return token::EPL_TOK_LBRACE; }
"}"                       { return token::EPL_TOK_RBRACE; }
"("                       { return token::EPL_TOK_LPAREN; }
")"                       { return token::EPL_TOK_RPAREN; }
"["                       { return token::EPL_TOK_LBRACK; }
"]"                       { return token::EPL_TOK_RBRACK; }
","                       { return token::EPL_TOK_COMMA; }
":"                       { return token::EPL_TOK_COLON; }
"."                       { return token::EPL_TOK_DOT; }
";"                       { return token::EPL_TOK_SEMICOLON; }

"+"                       { return token::EPL_TOK_PLUS; }
"-"                       { return token::EPL_TOK_MINUS; }
"*"                       { return token::EPL_TOK_TIMES; }
"/"                       { return token::EPL_TOK_DIV; }
"<"                       { return token::EPL_TOK_LT; }
"<="                      { return token::EPL_TOK_LE; }
">"                       { return token::EPL_TOK_GT; }
">="                      { return token::EPL_TOK_GE; }
"=="                      { return token::EPL_TOK_EQ; }
"!="                      { return token::EPL_TOK_NE; }
"&&"                      { return token::EPL_TOK_AND; }
"||"                      { return token::EPL_TOK_OR; }
"="                       { return token::EPL_TOK_ASSIGN; }

{number}                  { 
                            yylval->ival = atoi(yytext); 
                            return token::EPL_TOK_NUMBER; 
                          }

{id}                      { 
                            yylval->strval = new std::string(yytext);
                            return token::EPL_TOK_ID; 
                          }

{string}                  {  
                            yylval->strval = new std::string(yytext);
                            return token::EPL_TOK_STRING; 
                          }

{blank}+                  { yylloc->step(); }

{newline}+                { yylloc->lines(yyleng); yylloc->step(); }

.                         {
                            std::cout << "[ANY:" << yytext << "]" << std::endl;
                          }

<COMMENT>{
{newline}+                { BEGIN(INITIAL); }
.                         { }
}

%%
